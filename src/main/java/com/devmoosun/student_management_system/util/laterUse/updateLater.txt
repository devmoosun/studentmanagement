@PostMapping("/api/students")
public ResponseEntity<?> createStudent(@Valid @RequestBody StudentDto dto, BindingResult result) {
    if (result.hasErrors()) {
        Map<String, Object> errors = new HashMap<>();
        errors.put("fieldErrors", result.getFieldErrors().stream()
            .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage)));
        errors.put("globalErrors", result.getGlobalErrors().stream()
            .map(ObjectError::getDefaultMessage)
            .toList());
        return ResponseEntity.badRequest().body(errors);
    }

    StudentDto saved = studentService.save(dto);
    return ResponseEntity.ok(saved);
}
{
  "fieldErrors": {
    "name": "Name is required",
    "course": "Course must be at least 3 chars"
  },
  "globalErrors": [
    "Invalid student information"
  ]
}



=========
// /js/students/student-form.js
import { fetchJSON, showError, showLoading, getIdFromPath } from '../utils.js';
import { setPageMeta } from '../meta.js';

document.addEventListener('DOMContentLoaded', async () => {
  const form = document.getElementById('studentForm');
  const id = getIdFromPath();
  const metaUrl = id ? '/api/meta/student-edit' : '/api/meta/student-new';

  try {
    const meta = await fetchJSON(metaUrl);
    setPageMeta(meta);
  } catch (err) {
    console.warn('Meta load failed:', err);
  }

  if (id) await loadStudent(id);
  form?.addEventListener('submit', async (e) => handleSubmit(e, id));
});

async function loadStudent(id) {
  const form = document.getElementById('studentForm');
  showLoading(form, 'Loading student...');

  try {
    const student = await fetchJSON(`/api/students/${id}`);
    form.name.value = student.name || '';
    form.course.value = student.course || '';
  } catch (err) {
    showError(err.message || 'Failed to load student.', form);
  }
}

async function handleSubmit(e, id) {
  e.preventDefault();
  const form = e.target;
  clearErrors(form);

  const payload = {
    name: form.name.value.trim(),
    course: form.course.value.trim(),
  };

  const method = id ? 'PUT' : 'POST';
  const url = id ? `/api/students/${id}` : '/api/students';
  showLoading(form, id ? 'Updating...' : 'Creating...');

  try {
    await fetchJSON(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    form.innerHTML = `
      <div class="alert alert-success text-center">
        Student ${id ? 'updated' : 'added'} successfully!
      </div>
      <a href="/students" class="btn btn-outline-secondary w-100 mt-3">Back to List</a>
    `;
  } catch (err) {
    console.error(err);
    if (err.fieldErrors || err.globalErrors) {
      displayValidationErrors(form, err);
    } else {
      showError(err.message || `Failed to ${id ? 'update' : 'add'} student.`, form);
    }
  }
}

function clearErrors(form) {
  form.querySelectorAll('.invalid-feedback').forEach(el => el.remove());
  form.querySelectorAll('.is-invalid').forEach(el => el.classList.remove('is-invalid'));
  const global = document.getElementById('form-error');
  if (global) global.remove();
}

function displayValidationErrors(form, { fieldErrors, globalErrors }) {
  if (globalErrors?.length) {
    const div = document.createElement('div');
    div.id = 'form-error';
    div.className = 'alert alert-danger text-center mb-3';
    div.textContent = globalErrors.join(', ');
    form.prepend(div);
  }

  if (fieldErrors) {
    Object.entries(fieldErrors).forEach(([field, message]) => {
      const input = form.querySelector(`[name="${field}"]`);
      if (input) {
        input.classList.add('is-invalid');
        const feedback = document.createElement('div');
        feedback.className = 'invalid-feedback';
        feedback.textContent = message;
        input.after(feedback);
      }
    });
  }
}


===========

<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout}" lang="en">
<body>
<main layout:fragment="content" class="container my-4">
  <h2 id="form-title">Student Form</h2>

  <!-- Global error container -->
  <div id="form-error"></div>

  <form id="studentForm" class="mt-4">
    <input type="hidden" id="studentId">

    <div class="mb-3">
      <label for="name" class="form-label">Name</label>
      <input type="text" id="name" name="name" class="form-control" required>
    </div>

    <div class="mb-3">
      <input type="text" id="course" name="course" class="form-control" required>
    </div>

    <div class="d-flex gap-2">
      <button type="submit" class="btn btn-success">Save</button>
      <a href="/students" class="btn btn-outline-secondary">Cancel</a>
    </div>
  </form>
</main>

<!-- JS Module -->
<script type="module" th:src="@{/js/students/student-form.js}"></script>
</body>
</html>

==========


Updates util

// /js/utils.js
export async function fetchJSON(url, options = {}) {
  const res = await fetch(url, options);
  const contentType = res.headers.get('Content-Type') || '';

  let data = null;
  if (contentType.includes('application/json')) {
    data = await res.json();
  } else {
    data = await res.text();
  }

  if (!res.ok) {
    // Handle Spring validation error object
    if (data && typeof data === 'object' && (data.fieldErrors || data.globalErrors)) {
      throw data; // Pass structured validation errors up
    }

    // Otherwise throw normal message
    throw new Error(data?.message || data || 'Request failed');
  }

  return data;
}
